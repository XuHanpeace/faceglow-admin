---
alwaysApply: true
---

# FaceGlow项目架构设计Rules

## 1. 架构设计原则
- **分层架构**：严格区分UI层、业务逻辑层、数据访问层、服务层
- **单一职责**：每个组件、函数、类只负责一个明确的功能
- **依赖倒置**：高层模块不应依赖低层模块，两者都应该依赖抽象
- **开闭原则**：对扩展开放，对修改封闭

## 2. 组件架构设计
- **组件拆分**：复杂组件必须拆分为多个职责单一的子组件
- **容器组件与展示组件**：分离业务逻辑与UI展示
- **组件大小限制**：单个组件文件不超过300行代码
- **Props最小化**：组件接收的Props应尽可能精简
- **React.memo有选择性使用**：仅在组件确实受益于记忆化时使用，避免过度优化
- **useCallback/useMemo有选择性使用**：仅在确实解决性能问题时使用，避免过度优化

## 3. 函数设计原则
- **函数长度**：单个函数不超过30行代码
- **参数数量**：函数参数不超过3个，超过时使用对象参数
- **纯函数优先**：优先编写无副作用的纯函数
- **返回值一致性**：统一返回格式，如 `{ success: boolean, data?: any, error?: string }`
- **错误处理**：每个异步操作必须有try-catch处理

## 4. 状态管理架构
- **Redux Toolkit**：使用Redux Toolkit管理全局状态
- **Slice分离**：按功能将状态管理逻辑分离到不同slice
- **异步操作**：使用createAsyncThunk处理异步操作
- **状态不可变性**：在Redux中使用immer-like不可变更新（通过Redux Toolkit的immer支持）
- **副作用隔离**：将副作用操作与UI逻辑分离

## 5. 业务逻辑分层
- **服务层**：封装业务逻辑，与UI无关（如authService, taskService）
- **数据访问层**：封装API调用和数据库操作（如userWorkService, albumService）
- **领域模型**：在types/model中定义业务实体和领域逻辑
- **用例层**：在store/slices中封装完整的业务用例

## 6. 数据流设计
- **单向数据流**：遵循Redux的状态管理模式
- **异步操作处理**：使用Redux Thunk处理异步操作
- **缓存策略**：合理设计数据缓存机制（如categoryCache, homeAlbumCache）
- **数据同步**：确保本地状态与服务器状态同步

## 7. 导航架构
- **导航扁平化**：避免过深的导航层级
- **参数传递**：使用类型安全的导航参数（RootStackParamList）
- **导航状态管理**：合理管理导航相关的状态
- **深度链接**：支持应用内外的深度链接

## 8. 网络请求分层
- **HTTP客户端抽象**：使用Axios创建统一的HTTP客户端（clients.ts）
- **请求拦截器**：统一处理认证、错误等（initHttpInterceptors）
- **响应处理**：统一处理API响应和错误
- **重试机制**：实现网络请求的重试逻辑

## 9. 存储分层
- **MMKV存储**：使用MMKV进行本地存储（如authService中的storage）
- **数据持久化**：合理设计数据持久化策略
- **缓存策略**：区分短期缓存和长期存储
- **数据迁移**：处理存储数据的版本升级

## 10. Hooks设计
- **自定义Hooks**：将可复用逻辑提取为自定义Hooks（如useUser, useUserSelfies）
- **Hooks职责单一**：每个自定义Hook只处理一个特定功能
- **依赖关系清晰**：明确Hooks的依赖关系
- **副作用管理**：在Hooks中正确处理副作用

## 11. 类型系统设计
- **TypeScript优先**：所有代码必须使用TypeScript
- **禁止使用any**：严禁在代码中使用`any`类型
- **unknown优先**：不确定类型时使用`unknown`，配合类型守卫使用
- **接口定义**：为所有数据结构定义清晰的接口（types/目录）
- **联合类型**：合理使用联合类型表达业务状态
- **泛型使用**：在合适的地方使用泛型提高复用性
- **类型守卫**：使用类型守卫验证运行时数据类型
- **类型断言谨慎**：避免过度使用类型断言

## 12. 错误处理架构
- **统一错误处理**：创建统一的错误处理机制（如AsyncTaskError）
- **用户友好错误**：向用户显示可理解的错误信息
- **错误恢复**：提供错误恢复机制
- **日志记录**：在关键位置记录错误日志

## 13. 性能优化架构
- **懒加载**：组件和数据使用懒加载（如LazyComponent）
- **虚拟滚动**：长列表使用FlatList等优化
- **内存管理**：及时清理事件监听器、定时器等资源
- **React.memo有选择性使用**：仅在组件确实受益于记忆化时使用，避免过度优化
- **useCallback/useMemo有选择性使用**：仅在确实解决性能问题时使用，避免过度优化
- **图片优化**：使用FastImage等优化图片加载
- **性能分析**：使用React DevTools Profiler等工具分析性能瓶颈

## 14. 测试架构
- **可测试性设计**：编写易于测试的纯函数和组件
- **分层测试**：单元测试、集成测试、端到端测试
- **Mock策略**：为外部依赖提供Mock实现
- **测试覆盖率**：确保关键业务逻辑有充分的测试覆盖

## 15. 代码组织架构
- **功能分组**：按功能而非类型组织文件（components, services, store, hooks等）
- **模块化设计**：将相关功能组织成模块
- **依赖管理**：清晰管理模块间的依赖关系
- **命名规范**：使用一致的命名约定

## 16. 配置管理
- **环境配置**：分离开发、测试、生产环境配置（cloudbaseConfig）
- **常量管理**：统一管理应用常量
- **配置类型安全**：为配置项提供类型定义
- **动态配置**：支持运行时配置更新

## 17. 工具函数分层
- **通用工具**：创建跨模块的通用工具函数（utils/目录）
- **业务工具**：创建特定业务域的工具函数（如albumUtils）
- **工具函数测试**：为工具函数编写单元测试
- **工具函数文档**：为复杂工具函数提供文档

## 18. 重构原则
- **渐进式重构**：避免大规模重写，采用渐进式重构
- **测试先行**：重构前确保有足够的测试覆盖
- **架构演进**：允许架构随业务发展演进
- **文档同步**：重构后及时更新架构文档

## 19. 业务逻辑优化
- **函数拆分**：将大型函数拆分为多个小函数（如BeforeCreationScreen中的handleUseStylePress）
- **状态管理**：将复杂的状态逻辑提取到Redux或自定义Hook中
- **副作用处理**：将副作用（如API调用、存储操作）与UI逻辑分离
- **缓存策略**：合理使用缓存避免重复计算和请求
- **性能优化**：仅在确实存在性能问题时进行优化，优先解决算法复杂度问题
